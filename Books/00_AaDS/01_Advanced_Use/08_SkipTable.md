---
title: 跳表
---

# 跳表 - Skip Table

上章节将来二分查找，主要依赖于数组得随机访问特性来实现，所以只能使用数组。但是如果数据储存在链表中，真的没有办法查找吗？

实际上，只需要对链表进行改造，就可以支持类似于“二分”的查找算法。我们把改造后的数据结构叫做**跳表**。全称**跳跃列表（Skip List）**。

跳表这种数据结构对你来说，可能会比较陌生，因为一般的数据结构和算法书籍里都不怎么会讲。但是它确实是一种各方面性能都比较优秀的**动态数据结构**，可以支持快速地插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树（Red-black tree）。

Redis 中的有序集合（Sorted Set）就是用跳表来实现一部分的。如果你有一定基础，应该知道红黑树也可以实现快速地插入、删除和查找操作。**那 Redis 为什么会选择用跳表来实现有序集合呢？**

## 如何理解跳表？

对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度就会很高，是 O(n)。

那么如何提高查找效率呢？如果像下图所示，对链表建立一级“索引”，查找起来是不是就更快呢？ 每两个结点提取一个结点到上一级，把抽出来的那一级叫做**索引**或者**索引层**。图中 down 表示 down 指针，指向下一级结点。

![跳表-跳表索引层](https://archive.static.spiritling.net/images/08_SkipTable-SkipListIndexLayer.png)

如果我们现在要查找某个结点，比如 16。我们可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，我们发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。然后我们通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时候，我们只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。

从这个例子里，我们看出，**加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了**。那如果我们再加一级索引呢？效率会不会提升更多呢？

![跳表-跳表索引二层](https://archive.static.spiritling.net/images/08_SkipTable-SkipListIndexLevelTwo.png)

跟前面建立第一级索引的方式相似，我们在第一级索引的基础之上，每两个结点就抽出一个结点到第二级索引。现在我们再来查找 16，只需要遍历 6 个结点了，需要遍历的结点数量又减少了。

上面举的例子数据量都是比较小的，所以感觉索引级数的增加，并没有提高多大的效率，但是如果在数据量多的情况下，比如 64 个数据，查找第 62 个，传统方式则会需要遍历 62 个结点，但是如果经过索引后，最高级索引只有 2 个时，只需要遍历 11 个结点，效率提升了许多。

| 索引层级   | 结点数 |
| ---------- | ------ |
| 第五级索引 | 2      |
| 第四级索引 | 4      |
| 第三级索引 | 8      |
| 第二级索引 | 16     |
| 第一级索引 | 32     |
| 原始数据   | 64     |

前面讲的**这种链表加多级索引的结构，就是跳表**。

## 用跳表查询有多快？

算法的执行效率可以通过时间复杂度来度量，同样的，我们可以在这里使用时间复杂度来度量跳表的执行效率。在一个单链表中查询某个数据的时间复杂度是 O(n)。那么在一个具有多级索引的跳表中，查询某个数据的时间复杂度是多少呢？

这个时间复杂度比较复杂，我们可以将问题分解，先看一个问题，如果链表中有 n 个结点，那么会有多少级索引呢？

按照上面举得例子，每两个结点抽出一个结点作为上一级索引的结点，那第一级索引结点就是 n/2，第二级索引结点数就是 n/4，第三级索引结点数就是 n/8，依次类推，也就是说，**第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k 级索引结点的个数就是 n/(2k)。**

假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/(2h)=2，从而求得 h=log2n-1。如果包含原始链表这一层，整个跳表的高度就是 log2n。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m\*logn)。

这个 m 的值是多少呢？按照前面这种索引结构，我们每一级索引都最多只需要遍历 3 个结点。

为什么是 3 个结点呢？比如说现在这一层下来后数据是 10，后续是 20，30 两个结点，而你查询的数据是 25，这个时候你需要先把 10 和 20 查询了，那么第三个呢？可能有人就说直接去下一个层级就可以了，但是如果第三个数据是 25 呢？这里数据并不连续，第三个数据可能是任何大于 21 的值，怎么办？当然是查询一次，所以本层就查询了三个结点，也就是 m 就是 3。所以在跳表中查询任意数据的时间复杂度就是 O(logn)。

这个查找的时间复杂度跟二分查找是一样的。换句话说，我们其实是基于单链表实现了二分查找，是不是很神奇。但是，天下没有免费的午餐，这种查询效率的提升，前提是建立了很多索引，也就是我们说过的空间换时间的设计思路。

## 跳表是不是很浪费内存？

比起普通的单链表，跳表需要存储多级索引，肯定需要耗费更多的存储空间。那么到底需要多少呢？我们可以根据空间复杂度来分析下。

跳表的空间复杂度分析并不难，我在前面说了，假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。

这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的空间复杂度是 O(n)。也就是说，如果将包含 n 个结点的单链表构造成跳表，我们需要额外再用接近 n 个结点的存储空间。那我们有没有办法降低索引占用的内存空间呢？

我们前面都是每两个结点抽一个结点到上级索引，如果我们每三个结点或五个结点，抽一个结点到上级索引，是不是就不用那么多索引结点了呢？

第一级索引需要大约 n/3 个结点，第二级索引需要大约 n/9 个结点。每往上一级，索引结点个数都除以 3。为了方便计算，我们假设最高一级的索引结点个数是 1。我们把每级索引的结点个数都写下来，也是一个等比数列。

通过等比数列求和公式，总的索引结点大约就是 n/3+n/9+n/27+…+9+3+1=n/2。尽管空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。

通过上面的两个间隔例子，其实也可以说出一个问题，**那就是跳表可以通过改变索引构建策略，有效平衡执行效率和内存消耗。这是一个优势**。

实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。

## 跳表索引动态更新

当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。

![跳表-不更新索引插入](https://archive.static.spiritling.net/images/08_SkipTable-NotUpdateIndexInsert.png)

作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。

如果你了解红黑树、AVL 树这样平衡二叉树，你就知道它们是通过左右旋的方式保持左右子树的大小平衡，不了解也没关系，而跳表是通过随机函数来维护“平衡性”。

通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那就将这个结点添加到第一级到第 K 级这 K 级索引中。

随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。

## 总结

Redis 中的有序集合是通过跳表来实现的，严格意义上来说，其实还用了散列表等其他方式，将性能设计到极致了。在 Redis 的开发中，就会发现，Redis 中的有序集合支持的操作核心操作主要有下面这几个：

- 插入一个数据
- 删除一个数据
- 查找一个数据
- 通过区间查找数据
- 迭代输出有序序列

其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，**按照区间来查找数据这个操作，红黑树的效率没有跳表高**。

对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。

但是，在实际编程使用中，因为红黑树比跳表出现的更早，所以一般编程语言中的 Map 类型都是通过红黑树来实现的，而我们在实现业务时，直接就可以使用，而不必去自己实现一个红黑树，但是跳表没有现成的，所以需要我们手动实现一个跳表，尤其是里面的随机函数的问题比较难写，需要平衡执行效率和内存消耗。
